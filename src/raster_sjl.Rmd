# load the netcdf and raster packages
```{r}
library(ncdf4)
library(raster)
```

The data are held in netCDF files. We don't work directly with the netCDFs in R. Instad we load a netcdf file and convert it to a raster brick so we can work with it. In this example the netCDF I'll use is called '1993_01_salinity.nc'.I've sent it to you in the email with this code.

```{r}
nc <-  "../data/env/netcdf/1993_01_salinity.nc" # change the file path to where ever your netcdfs are saved
rasbr <- brick(nc,lvar = 4) #lvar = 4 is used because the netCDF contains four dimensions. Without this command, the raster brick will only have one level (the top one, which is my surface data)
rasbr # this will give you some information about the raster brick
```

We no longer care that the data originated from a netCDF file. Everything now is done with the raster brick.

We can plot the different layers (which represent depth) inside the raster brick.

Plot the top layer
```{r}
plot(rasbr[[1]]) #the double brackets tell R which layer to plot
```

plot layer 20
```{r}
plot(rasbr[[20]]) 
```

If you look back to the output of 'rasbr' and look at 'coord. ref.', you can see that the CRS (coordinate reference system) is in WGS84 (+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0)

Because I am using these files for Maxent, I need the projection to be an albers equal area. We can project the whole raster brick. There are a couple of ways to do this, but the simplest way is to use an existing file in the projection I want. The file I will use for this is called aea.tif. I've sent it to you in the email with this code as a zip. Note that there are two files in the zip folder - you will need both (but you only call on the .tif in the code) 
```{r}
aea <- raster("../output/env/aea.tif") # change the file path to where ever the tif and .twf files are saved
rasbr_aea <- projectRaster(rasbr, aea) 
plot(rasbr_aea[[1]]) # just to look at the top layer of the raster brick after projection so you can see the difference
```

The next piece of data we need is the observation data itself. I've sent you the observations.csv in the email with this code.
```{r}
obs <- read.csv("../data/observations3.csv", header = TRUE) #change this path to your .csv location
head(obs)
```
A note about obs$depth. This is not a measurement, but relates to the layer in the raster bricks. E.G. the observation in row one was found at rasbr[[15]], the observation in row 3 at rasbr[[17]]. I created this field myself.

The lon and lat represent meters as oppose to decimal degrees so it is 'albers equal area' ready.
For this exercise, I'm going to ignore year, month, and depth and just do a straightforward extract to points.

First we need to convert 'obs' into a 'spatialpoints dataframe'
```{r}
xy <- obs[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
obssp <- SpatialPointsDataFrame(coords = xy, data = obs, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
obssp
```

We can plot the observations on any layer of the 'rasbr_aea ' brick
```{r}
plot(rasbr_aea[[1]]) #plot layer 1 - the top layer
points(obssp$lon, obssp$lat)
```

The code to extract the valuees from any layer in 'rasbr_aea' is very simple
```{r}
obssp$salinity <- extract(x=rasbr_aea[[1]], y = obssp) #extract from the top layer of the rasbr_aea and add to the obssp dataset in a new column called salinity
head(obssp) # just to take a look at the output
```


I can write this 'spatialpoints dataframe' to a .csv and convert it back to a 'normal dataframe'.
```{r}
write.csv(obssp, file = "../output/bio/observations_sal.csv", row.names = FALSE) # change the path to where ever you would like to save it
obs <- as.data.frame(obssp) # this coverts the 'spatialpoints dataframe' to a 'normal dataframe'
obs # just to take a look at the output
```

for some reason converting the 'spatialpoints dataframe' to a 'normal dataframe' adds a duplicate lon and lat column (the write.csv function does the same). I don't know why, but they are easy to remove so I am not worried about it.

#shawn code

SL I AM DOING SOME STUFF HERE :O) 
THE ABOVE EXTRACTION IS THE HOOK UP. I WANT TO EXTRACT FOR A CERTAIN DEPTH DEFINED BY OBSSP IN ORDER TO AUTOMATE THIS. THIS MEANS YOU NEED
TO MAKE [[]] LINKED TO DEPTH...LET'S SEE IF WE CAN DO THIS NOW.
```{r}
obssp$salinity2 <- extract(x=rasbr_aea[[obssp$depth]], y = obssp)
obssp$salinity2 # just to take a look at the output
```

Ok, the above is close but not right. It is printing salinity for depths 15, 22, 17, 18, 15, 16, 16 for each observation record.
At least this is what I think. Let's check it out.
```{r}
obssp$salinity22 <- extract(x=rasbr_aea[[22]], y = obssp) #I expect this to be 33.42. Yep.
obssp$salinity22
```

Starting over now I have created a smaller observation file with only 3 records. 
Gonna create a loop here and iterate over the depths listed in the observation file
```{r}
Data_Loop <-NULL #Gonna put my loop data in here
for (i in obssp$depth) { #cycle through values in depth column (15, 22, 17)
  #this is the equation you will be calculating for every value of y
  sal <- extract(x=rasbr_aea[[i]], y = obssp) #create a data list
  
  #Put your data in a data frame. Don't forget to enclose this within the loop!
  Data_Loop <- rbind(Data_Loop, data.frame(depth=i, year=obssp$year, month=obssp$month, lon=obssp$lon, lat=obssp$lat, Salinity=sal))
  
  #print the i value so you can track progress. Good for longer loops
  print(i)
  #Close the loop
  }
Data_Loop
```

SL: TRY IT ANOTHER WAY. Problem is that we need to tell x to be at specific depth as specified by obssp$depth and y to be only the lat and lon at that depth.
The two examples here (one above and one below) are VERY close. Just a matter of tweaking and playing around a bit more. See if you can figure it out.
```{r}
Data_Loop <-NULL #Gonna put my loop data in here
for (i in 1:length(obssp)) { #cycle through values in depth column (15, 22, 17) #NO IT CYCLES THROUGH THE ROWS
  #this is the equation you will be calculating for every value of y
  sal <- extract(x=rasbr_aea[[obssp$depth[i]]], y = obssp[i,]) #go with i row in obssp
  
  #Put your data in a data frame. Don't forget to enclose this within the loop!
  Data_Loop <- rbind(Data_Loop, data.frame(depth=obssp$depth, year=obssp$year, month=obssp$month, lon=obssp$lon, lat=obssp$lat, Salinity=sal))
  
  #print the i value so you can track progress. Good for longer loops
  print(i)
  #Close the loop
}
Data_Loop
```

# sam tests on shawns loop

let's get the values manually
```{r}
testrow1 <- read.csv("../data/row1.csv", header = TRUE)
testrow1xy <- testrow1[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow1sp <- SpatialPointsDataFrame(coords = testrow1xy, data = testrow1, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
testrow1sp
test15 <- extract(x=rasbr_aea[[15]], y = testrow1sp)
test15
testrow2 <- read.csv("../data/row1.csv", header = TRUE)
testrow2xy <- testrow2[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow2sp <- SpatialPointsDataFrame(coords = testrow2xy, data = testrow2, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
testrow2sp
test22 <- extract(x=rasbr_aea[[22]], y = testrow2sp)
test22
testrow3 <- read.csv("../data/row1.csv", header = TRUE)
testrow3xy <- testrow3[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow3sp <- SpatialPointsDataFrame(coords = testrow3xy, data = testrow3, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
testrow3sp
test17 <- extract(x=rasbr_aea[[17]], y = testrow3sp)
test17
```

row 1 (dpeth 15) should be 32.8761...
row 2 (depth 22) should be 33.10022...
row 3 (depth 17) should be 32.90343...



this loop replaces the values in obssp$samtest with the last depth layer... ie. the process does not work for each row in obssp in turn
```{r}
Data_Loop <-NULL #Gonna put my loop data in here
for (i in 1:length(obssp)) {  # CYCLES THROUGH THE ROWS
  de <- obssp$depth[[i]]  #have a variable for the depth layer
  print(de)
  obssp$samtest <- extract(x=rasbr_aea[[de]], y = obssp) #this is the equation you will be calculating for every value of y
  
  #Put your data in a data frame. Don't forget to enclose this within the loop!
  #Data_Loop <- rbind(Data_Loop, data.frame(depth=obssp$depth, year=obssp$year, month=obssp$month, lon=obssp$lon, lat=obssp$lat, Salinity=sal))
  
  #print the i value so you can track progress. Good for longer loops
  #print(i)
  #Close the loop
}
#Data_Loop
obssp$samtest
```

take 2

```{r}
#Data_Loop <-NULL #Gonna put my loop data in here
for (i in 1:length(obssp)) {  # CYCLES THROUGH THE ROWS
  de <- obssp$depth[[i]]  #have a variable for the depth layer
  #print(de)
  obssp$samtest[i] <- extract(x=rasbr_aea[[de]], y = obssp) #this is the equation you will be calculating for every value of y
  
  #Put your data in a data frame. Don't forget to enclose this within the loop!
  #Data_Loop <- rbind(Data_Loop, data.frame(depth=obssp$depth, year=obssp$year, month=obssp$month, lon=obssp$lon, lat=obssp$lat, Salinity=sal))
  
  #print the i value so you can track progress. Good for longer loops
  print(i)
  #Close the loop
}
#Data_Loop
obssp$samtest
obssp
```

so with this code, the values are correct but I get the following error "number of items to replace is not a multiple of replacement length". I don't know why... but it works...



Ok next step, can you dynamically name the column with the variable in question (or at least the name of the original netcdf)




