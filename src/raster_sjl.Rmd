# load the netcdf and raster packages
```{r}
library(ncdf4)
library(raster)
library(rgdal)
```

The data are held in netCDF files. We don't work directly with the netCDFs in R. Instad we load a netcdf file and convert it to a raster brick so we can work with it. In this example the netCDF I'll use is called '1993_01_salinity.nc'.I've sent it to you in the email with this code.

```{r}
nc <-  "../data/env/netcdf/1993_01_salinity.nc" # change the file path to where ever your netcdfs are saved
rasbr <- brick(nc,lvar = 4) #lvar = 4 is used because the netCDF contains four dimensions. Without this command, the raster brick will only have one level (the top one, which is my surface data)
rasbr # this will give you some information about the raster brick
```

We no longer care that the data originated from a netCDF file. Everything now is done with the raster brick.

We can plot the different layers (which represent depth) inside the raster brick.

Plot the top layer
```{r}
plot(rasbr[[1]]) #the double brackets tell R which layer to plot
```

plot layer 20
```{r}
plot(rasbr[[20]]) 
```

If you look back to the output of 'rasbr' and look at 'coord. ref.', you can see that the CRS (coordinate reference system) is in WGS84 (+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0)

Because I am using these files for Maxent, I need the projection to be an albers equal area. We can project the whole raster brick. There are a couple of ways to do this, but the simplest way is to use an existing file in the projection I want. The file I will use for this is called aea.tif. I've sent it to you in the email with this code as a zip. Note that there are two files in the zip folder - you will need both (but you only call on the .tif in the code) 
```{r}
aea <- raster("../output/env/aea.tif") # change the file path to where ever the tif and .twf files are saved
rasbr_aea <- projectRaster(rasbr, aea) 
plot(rasbr_aea[[1]]) # just to look at the top layer of the raster brick after projection so you can see the difference
rasbr_aea
```

The next piece of data we need is the observation data itself. I've sent you the observations.csv in the email with this code.
```{r}
obs <- read.csv("../data/observations3.csv", header = TRUE) #change this path to your .csv location
obs$month <- sprintf("%02d",obs$month) # new addition to add the 0 infront of single digit... test for seeing if you can match the netcdf name for year month selection of bricks
head(obs)

```
A note about obs$depth. This is not a measurement, but relates to the layer in the raster bricks. E.G. the observation in row one was found at rasbr[[15]], the observation in row 3 at rasbr[[17]]. I created this field myself.

The lon and lat represent meters as oppose to decimal degrees so it is 'albers equal area' ready.
For this exercise, I'm going to ignore year, month, and depth and just do a straightforward extract to points.

First we need to convert 'obs' into a 'spatialpoints dataframe'
```{r}
xy <- obs[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
obssp <- SpatialPointsDataFrame(coords = xy, data = obs, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
obssp
```

We can plot the observations on any layer of the 'rasbr_aea ' brick
```{r}
plot(rasbr_aea[[1]]) #plot layer 1 - the top layer
points(obssp$lon, obssp$lat)
```

The code to extract the valuees from any layer in 'rasbr_aea' is very simple
```{r}
obssp$salinity <- extract(x=rasbr_aea[[1]], y = obssp) #extract from the top layer of the rasbr_aea and add to the obssp dataset in a new column called salinity
head(obssp) # just to take a look at the output
```


I can write this 'spatialpoints dataframe' to a .csv and convert it back to a 'normal dataframe'.
```{r}
write.csv(obssp, file = "../output/bio/observations_sal.csv", row.names = FALSE) # change the path to where ever you would like to save it
obs <- as.data.frame(obssp) # this coverts the 'spatialpoints dataframe' to a 'normal dataframe'
obs # just to take a look at the output
```

for some reason converting the 'spatialpoints dataframe' to a 'normal dataframe' adds a duplicate lon and lat column (the write.csv function does the same). I don't know why, but they are easy to remove so I am not worried about it.

#shawn code

SL I AM DOING SOME STUFF HERE :O) 
THE ABOVE EXTRACTION IS THE HOOK UP. I WANT TO EXTRACT FOR A CERTAIN DEPTH DEFINED BY OBSSP IN ORDER TO AUTOMATE THIS. THIS MEANS YOU NEED
TO MAKE [[]] LINKED TO DEPTH...LET'S SEE IF WE CAN DO THIS NOW.
```{r}
obssp$salinity2 <- extract(x=rasbr_aea[[obssp$depth]], y = obssp)
obssp$salinity2 # just to take a look at the output
```

Ok, the above is close but not right. It is printing salinity for depths 15, 22, 17, 18, 15, 16, 16 for each observation record.
At least this is what I think. Let's check it out.
```{r}
obssp$salinity22 <- extract(x=rasbr_aea[[22]], y = obssp) #I expect this to be 33.42. Yep.
obssp$salinity22
```

Starting over now I have created a smaller observation file with only 3 records. 
Gonna create a loop here and iterate over the depths listed in the observation file
```{r}
Data_Loop <-NULL #Gonna put my loop data in here
for (i in obssp$depth) { #cycle through values in depth column (15, 22, 17)
  #this is the equation you will be calculating for every value of y
  sal <- extract(x=rasbr_aea[[i]], y = obssp) #create a data list
  
  #Put your data in a data frame. Don't forget to enclose this within the loop!
  Data_Loop <- rbind(Data_Loop, data.frame(depth=i, year=obssp$year, month=obssp$month, lon=obssp$lon, lat=obssp$lat, Salinity=sal))
  
  #print the i value so you can track progress. Good for longer loops
  print(i)
  #Close the loop
  }
Data_Loop
```

SL: TRY IT ANOTHER WAY. Problem is that we need to tell x to be at specific depth as specified by obssp$depth and y to be only the lat and lon at that depth.
The two examples here (one above and one below) are VERY close. Just a matter of tweaking and playing around a bit more. See if you can figure it out.
```{r}
Data_Loop <-NULL #Gonna put my loop data in here
for (i in 1:length(obssp)) { #cycle through values in depth column (15, 22, 17) #NO IT CYCLES THROUGH THE ROWS
  #this is the equation you will be calculating for every value of y
  sal <- extract(x=rasbr_aea[[obssp$depth[i]]], y = obssp[i,]) #go with i row in obssp
  
  #Put your data in a data frame. Don't forget to enclose this within the loop!
  Data_Loop <- rbind(Data_Loop, data.frame(depth=obssp$depth, year=obssp$year, month=obssp$month, lon=obssp$lon, lat=obssp$lat, Salinity=sal))
  
  #print the i value so you can track progress. Good for longer loops
  print(i)
  #Close the loop
}
Data_Loop
```

# sam tests on shawns loop

let's get the values manually at depth
```{r}
testrow1 <- read.csv("../data/row1.csv", header = TRUE)
testrow1xy <- testrow1[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow1sp <- SpatialPointsDataFrame(coords = testrow1xy, data = testrow1, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
testrow1sp
test15 <- extract(x=rasbr_aea[[15]], y = testrow1sp)
test15
testrow2 <- read.csv("../data/row1.csv", header = TRUE)
testrow2xy <- testrow2[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow2sp <- SpatialPointsDataFrame(coords = testrow2xy, data = testrow2, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
testrow2sp
test22 <- extract(x=rasbr_aea[[22]], y = testrow2sp)
test22
testrow3 <- read.csv("../data/row1.csv", header = TRUE)
testrow3xy <- testrow3[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow3sp <- SpatialPointsDataFrame(coords = testrow3xy, data = testrow3, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
testrow3sp
test17 <- extract(x=rasbr_aea[[17]], y = testrow3sp)
test17
```

row 1 (depth 15) should be 32.8761...
row 2 (depth 22) should be 33.10022...
row 3 (depth 17) should be 32.90343...


let's get the values manually at the surface
```{r}
testrow1.1 <- extract(x=rasbr_aea[[1]], y = testrow1sp)
testrow1.1
testrow2.1 <- extract(x=rasbr_aea[[1]], y = testrow2sp)
testrow2.1
testrow3.1 <- extract(x=rasbr_aea[[1]], y = testrow3sp)
testrow3.1
```

this loop replaces the values in obssp$samtest with the last depth layer... ie. the process does not work for each row in obssp in turn
```{r}
Data_Loop <-NULL #Gonna put my loop data in here
for (i in 1:length(obssp)) {  # CYCLES THROUGH THE ROWS
  de <- obssp$depth[[i]]  #have a variable for the depth layer
  print(de)
  obssp$samtest <- extract(x=rasbr_aea[[de]], y = obssp) #this is the equation you will be calculating for every value of y
  
  #Put your data in a data frame. Don't forget to enclose this within the loop!
  #Data_Loop <- rbind(Data_Loop, data.frame(depth=obssp$depth, year=obssp$year, month=obssp$month, lon=obssp$lon, lat=obssp$lat, Salinity=sal))
  
  #print the i value so you can track progress. Good for longer loops
  #print(i)
  #Close the loop
}
#Data_Loop
obssp$samtest
```

take 2

```{r}
for (i in 1:length(obssp)) {  # CYCLES THROUGH THE ROWS
  de <- obssp$depth[[i]]  #have a variable for the depth layer
  obssp$salinity_depth[i] <- extract(x=rasbr_aea[[de]], y = obssp) #this is the equation you will be calculating for every value of y
  obssp$salinity_surface[i] <- extract(x=rasbr_aea[[1]], y = obssp) #this is the equation you will be calculating for every value of y
  print(i)
}
obssp$salinity_depth
obssp$salinity_surface
```

so with this code, the values are correct but I get the following error "number of items to replace is not a multiple of replacement length". I don't know why... but it works...

test with just extracting the surface layer data..

```{r}
for (i in 1:length(obssp)) {  # CYCLES THROUGH THE ROWS
  obssp$testsurface[i] <- extract(x=rasbr_aea[[1]], y = obssp) #this is the equation you will be calculating for every value of y
  print(i)
  }
obssp$salinity_surface
obssp
```

scrap the variable name matching idea (instead just make a loop for each variable, and each variable held in a different folder). just try select by year and month.
note you have changed the dates on the .csv file so reload it

```{r warning=FALSE}
obs <- read.csv("../data/observations3.csv", header = TRUE) #change this path to your .csv location
obs$month <- sprintf("%02d",obs$month) # new addition to add the 0 infront of single digit... test for seeing if you can match the netcdf name for year month selection of bricks
xy <- obs[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
obssp <- SpatialPointsDataFrame(coords = xy, data = obs, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.


#the loop....
netcdf_list <- list.files("../data/env/testnetcdf/salinity", pattern = '*.nc', full.names = TRUE) #true means the full path is included
no_netcdf <- length(netcdf_list) #for the loop - need to know how many files to cycle through
netcdf_name <- list.files("../data/env/testnetcdf/salinity", pattern = '*.nc', full.names = FALSE) #false means the path is not included
library (ncdf4)
for (i in 1:no_netcdf){  
  print(netcdf_name[i]) #this just prints the name of the netCDF R is working on
  brkyr <- sapply(strsplit(netcdf_name[i], "_"), "[[", 1) # extracting the first part of the netcdf filename (which is the year)
  brkmth <- sapply(strsplit(netcdf_name[i], "_"), "[[", 2) # extracting the second part of the netcdf filename (which is the month)
  temp_brick <- brick(netcdf_list[i], lvar = 4)
  temp_brick <- projectRaster(temp_brick, aea) 
    for (j in 1:length(obssp)) {  
      print(j)
      de <- obssp$depth[[j]]  # a variable for the observation depth layer
      yr <- obssp$year[j]  # a variable for the observation year
      mth <- obssp$month[j]  # a variable for the observation month
      #I think i need an if statement here... if brkyr == yr & brkmth == mth do the data extraction below
        if (brkyr == yr & brkmth == mth){
          obssp$salinity_depth[j] <- extract(x=temp_brick[[de]], y = obssp) 
          obssp$salinity_surface[j] <- extract(x=temp_brick[[1]], y = obssp)
        }
    }
}

```


not extracting the correct values...

check

load in the three netcdfs
```{r}
nc1 <-  "../data/env/testnetcdf/salinity/1993_01_salinity.nc" # change the file path to where ever your netcdfs are saved
row1rast <- brick(nc1,lvar = 4) #lvar = 4 is used because the netCDF contains four dimensions. Without this command, the raster brick will only have one level (the top one, which is my surface data)
row1rast <- projectRaster(row1rast, aea)
row1rast
nc2 <-  "../data/env/testnetcdf/salinity/1998_01_salinity.nc" # change the file path to where ever your netcdfs are saved
row2rast <- brick(nc2,lvar = 4) #lvar = 4 is used because the netCDF contains four dimensions. Without this command, the raster brick will only have one level (the top one, which is my surface data)
row2rast <- projectRaster(row2rast, aea)
row2rast
nc3 <-  "../data/env/testnetcdf/salinity/1998_02_salinity.nc" # change the file path to where ever your netcdfs are saved
row3rast <- brick(nc3,lvar = 4) #lvar = 4 is used because the netCDF contains four dimensions. Without this command, the raster brick will only have one level (the top one, which is my surface data)
row3rast <- projectRaster(row3rast, aea)
row3rast
```

let's get the values manually at depth
```{r}
testrow1 <- read.csv("../data/row1.csv", header = TRUE)
#testrow1$month <- sprintf("%02d",testrow1$month)
testrow1xy <- testrow1[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow1sp <- SpatialPointsDataFrame(coords = testrow1xy, data = testrow1, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
testrow1sp
test15 <- extract(x=row1rast[[15]], y = testrow1sp)
test15
testrow2 <- read.csv("../data/row2.csv", header = TRUE)
#testrow2$month <- sprintf("%02d",testrow2$month)
testrow2xy <- testrow2[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow2sp <- SpatialPointsDataFrame(coords = testrow2xy, data = testrow2, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
testrow2sp
test22 <- extract(x=row2rast[[22]], y = testrow2sp)
test22
testrow3 <- read.csv("../data/row3.csv", header = TRUE)
#testrow3$month <- sprintf("%02d",testrow3$month)
testrow3xy <- testrow3[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow3sp <- SpatialPointsDataFrame(coords = testrow3xy, data = testrow3, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
testrow3sp
test17 <- extract(x=row3rast[[17]], y = testrow3sp)
test17
```

let's get the values manually at the surface
```{r}
testrow1.1 <- extract(x=row1rast[[1]], y = testrow1sp)
testrow1.1
testrow2.1 <- extract(x=row2rast[[1]], y = testrow2sp)
testrow2.1
testrow3.1 <- extract(x=row3rast[[1]], y = testrow3sp)
testrow3.1
```




shawn suggests creating a table/list of raster bricks with year and month data. Actually need to do this with the netCDFs (as you want to load the netCDF to convert)
```{r}
#the loop....
netcdf_list <- list.files("../data/env/testnetcdf/salinity", pattern = '*.nc', full.names = TRUE)
nctable <-as.data.frame(netcdf_list)
no_netcdf <- length(netcdf_list) 
netcdf_name <- list.files("../data/env/testnetcdf/salinity", pattern = '*.nc', full.names = FALSE) 
library (ncdf4)
for (i in 1:no_netcdf){  
  print(netcdf_name[i]) #this just prints the name of the netCDF R is working on
  nctable$year[i] <- sapply(strsplit(netcdf_name[i], "_"), "[[", 1)
  nctable$month[i] <- sapply(strsplit(netcdf_name[i], "_"), "[[", 2)
}  
  
```


a new loop... no this isnt going to work...
```{r warning=FALSE}
#the loop....
library (ncdf4)
netcdf_list <- list.files("../data/env/testnetcdf/salinity", pattern = '*.nc', full.names = TRUE) #true means the full path is included
netcdf_name <- list.files("../data/env/testnetcdf/salinity", pattern = '*.nc', full.names = FALSE) #false means the path is not included
for (j in 1:length(obssp)) {  
      print(j)
      de <- obssp$depth[[j]]  # a variable for the observation depth layer
      yr <- obssp$year[j]  # a variable for the observation year
      mth <- obssp$month[j]  # a variable for the observation month
      if (yr == nctable$year & mth == nctable$month) {
        temp_brick <- brick(netcdf_list[i], lvar = 4)
        temp_brick <- projectRaster(temp_brick, aea) 
        for (j in 1:length(obssp)) {  
        print(j)
        de <- obssp$depth[[j]]  # a variable for the observation depth layer
        obssp$salinity_depth[j] <- extract(x=temp_brick[[de]], y = obssp) 
        obssp$salinity_surface[j] <- extract(x=temp_brick[[1]], y = obssp)
        }
      }
}
```


hmmm play...
```{r}
obs <- read.csv("../data/observations3.csv", header = TRUE) #change this path to your .csv location
#obs$month <- sprintf("%02d",obs$month) # new addition to add the 0 infront of single digit... test for seeing if you can match the netcdf name for year month selection of bricks
xy <- obs[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
obssp <- SpatialPointsDataFrame(coords = xy, data = obs, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
```


```{r}
netcdf_list <- list.files("../data/env/testnetcdf/salinity", pattern = '*.nc', full.names = TRUE) #true means the full path is included
no_netcdf <- length(netcdf_list) #for the loop - need to know how many files to cycle through
netcdf_name <- list.files("../data/env/testnetcdf/salinity", pattern = '*.nc', full.names = FALSE) #false means the path is not included
library (ncdf4)
for (i in 1:no_netcdf){  
  print(netcdf_name[i]) #this just prints the name of the netCDF R is working one
  brkyr <- as.integer(sapply(strsplit(netcdf_name[i], "_"), "[[", 1)) # extracting the first part of the netcdf filename (which is the year)
  brkmth <- as.integer(sapply(strsplit(netcdf_name[i], "_"), "[[", 2)) # extracting the second part of the netcdf filename (which is the month)
  temp_brick <- brick(netcdf_list[i], lvar = 4)
  temp_brick <- projectRaster(temp_brick, aea) 
    for (j in 1:nrow(obssp)) {  
      print (j)
      de <- obssp$depth[[j]]  # a variable for the observation depth layer
      yr <- (obssp$year[j])  # a variable for the observation year
      mth <- (obssp$month[j])  # a variable for the observation month
      #I think i need an if statement here... if brkyr == yr & brkmth == mth do the data extraction below
        #for (k in 1:nrow(obssp)){
          if (brkyr == yr & brkmth == mth){
            obssp$salinity_depth[j] <- extract(x=temp_brick[[de]], y = obssp[j, ]) 
            obssp$salinity_surface[j] <- extract(x=temp_brick[[1]], y = obssp[j, ]) 
           }
          
        #} 
    }
}
```

```{r}
obssp$salinity_depth
obssp$salinity_surface
```
done! Next stage... with rows where the year month combo comes up more than once...

```{r}
obs <- read.csv("../data/observationslong.csv", header = TRUE) #change this path to your .csv location
#obs$month <- sprintf("%02d",obs$month) # new addition to add the 0 infront of single digit... test for seeing if you can match the netcdf name for year month selection of bricks
xy <- obs[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
obssp <- SpatialPointsDataFrame(coords = xy, data = obs, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
```


```{r}
netcdf_list <- list.files("../data/env/testnetcdf/salinity", pattern = '*.nc', full.names = TRUE) #true means the full path is included
no_netcdf <- length(netcdf_list) #for the loop - need to know how many files to cycle through
netcdf_name <- list.files("../data/env/testnetcdf/salinity", pattern = '*.nc', full.names = FALSE) #false means the path is not included
library (ncdf4)
for (i in 1:no_netcdf){  
  print(netcdf_name[i]) #this just prints the name of the netCDF R is working one
  brkyr <- as.integer(sapply(strsplit(netcdf_name[i], "_"), "[[", 1)) # extracting the first part of the netcdf filename (which is the year)
  brkmth <- as.integer(sapply(strsplit(netcdf_name[i], "_"), "[[", 2)) # extracting the second part of the netcdf filename (which is the month)
  temp_brick <- brick(netcdf_list[i], lvar = 4)
  temp_brick <- projectRaster(temp_brick, aea) 
    for (j in 1:nrow(obssp)) {  
      print (j)
      de <- obssp$depth[[j]]  # a variable for the observation depth layer
      yr <- (obssp$year[j])  # a variable for the observation year
      mth <- (obssp$month[j])  # a variable for the observation month
      #I think i need an if statement here... if brkyr == yr & brkmth == mth do the data extraction below
        #for (k in 1:nrow(obssp)){
          if (brkyr == yr & brkmth == mth){
            obssp$salinity_depth[j] <- extract(x=temp_brick[[de]], y = obssp[j, ]) 
            obssp$salinity_surface[j] <- extract(x=temp_brick[[1]], y = obssp[j, ]) 
           }
          
        #} 
    }
}
```

```{r}
obssp$salinity_depth
obssp$salinity_surface
```
output is  
> obssp$salinity_surface
[1] 32.82551 33.19321 32.18221 32.23423 32.61295 32.61270 32.39069
> obssp$salinity_depth
[1] 32.83107 33.19973       NA 32.51381       NA 32.61270 32.39358

next step - check to see if the values are correct (particularly interested in those NA...)

```{r}
plot(temp_brick[[40]])
```
for the NA - of course - the layer no longer exists at that depth (water shallower than that)

check the values for all layers manually


```{r}
test <- read.csv("../data/observationslong.csv", header = TRUE)
testrow1 <- test[1, ]
testrow1
#testrow1$month <- sprintf("%02d",testrow1$month)
testrow1xy <- testrow1[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow1sp <- SpatialPointsDataFrame(coords = testrow1xy, data = testrow1, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
test10 <- extract(x=row1rast[[10]], y = testrow1sp)
test10
testrow2 <- test[2, ]
#testrow2$month <- sprintf("%02d",testrow2$month)
testrow2xy <- testrow2[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow2sp <- SpatialPointsDataFrame(coords = testrow2xy, data = testrow2, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
test12 <- extract(x=row1rast[[12]], y = testrow2sp)
test12
testrow3 <- test[3, ]
testrow3xy <- testrow3[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow3sp <- SpatialPointsDataFrame(coords = testrow3xy, data = testrow3, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
testrow3sp
test40 <- extract(x=row3rast[[40]], y = testrow3sp)
test40
testrow4 <- test[4, ]
testrow4xy <- testrow4[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow4sp <- SpatialPointsDataFrame(coords = testrow4xy, data = testrow4, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
testrow4sp
test18 <- extract(x=row3rast[[18]], y = testrow4sp)
test18
testrow5 <- test[5, ]
testrow5xy <- testrow5[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow5sp <- SpatialPointsDataFrame(coords = testrow5xy, data = testrow5, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
test27 <- extract(x=row3rast[[27]], y = testrow5sp)
test27
testrow6 <- test[6, ]
testrow6xy <- testrow6[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow6sp <- SpatialPointsDataFrame(coords = testrow6xy, data = testrow6, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
test1 <- extract(x=row2rast[[1]], y = testrow6sp)
test1
testrow7 <- test[7, ]
testrow7xy <- testrow7[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow7sp <- SpatialPointsDataFrame(coords = testrow7xy, data = testrow7, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
test5 <- extract(x=row2rast[[5]], y = testrow7sp)
test5
```

and surface...
```{r}
test1.1 <- extract(x=row1rast[[1]], y = testrow1sp)
test2.1 <- extract(x=row1rast[[1]], y = testrow2sp)
test3.1 <- extract(x=row3rast[[1]], y = testrow3sp)
test3.1
test4.1 <- extract(x=row3rast[[1]], y = testrow4sp)
test4.1
test5.1 <- extract(x=row3rast[[1]], y = testrow5sp)
test5.1
test6.1 <- extract(x=row2rast[[1]], y = testrow6sp)
test6.1
test7.1 <- extract(x=row2rast[[1]], y = testrow7sp)
test7.1
```
pull up values you got from the loop...
```{r}
obssp$salinity_depth
```

```{r}
obssp$salinity_surface
```
ok so the loop works for repetitive years and months

now all the depth values were numbered - in reality I have some NA. How to deal...
.csv altered to include 1 NA

```{r}
obs <- read.csv("../data/observationslong.csv", header = TRUE) #change this path to your .csv location
#obs$month <- sprintf("%02d",obs$month) # new addition to add the 0 infront of single digit... test for seeing if you can match the netcdf name for year month selection of bricks
xy <- obs[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
obssp <- SpatialPointsDataFrame(coords = xy, data = obs, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
```


```{r}
netcdf_list <- list.files("../data/env/testnetcdf/salinity", pattern = '*.nc', full.names = TRUE) #true means the full path is included
no_netcdf <- length(netcdf_list) #for the loop - need to know how many files to cycle through
netcdf_name <- list.files("../data/env/testnetcdf/salinity", pattern = '*.nc', full.names = FALSE) #false means the path is not included
library (ncdf4)
for (i in 1:no_netcdf){  
  print(netcdf_name[i]) #this just prints the name of the netCDF R is working one
  brkyr <- as.integer(sapply(strsplit(netcdf_name[i], "_"), "[[", 1)) # extracting the first part of the netcdf filename (which is the year)
  brkmth <- as.integer(sapply(strsplit(netcdf_name[i], "_"), "[[", 2)) # extracting the second part of the netcdf filename (which is the month)
  temp_brick <- brick(netcdf_list[i], lvar = 4)
  temp_brick <- projectRaster(temp_brick, aea) 
    for (j in 1:nrow(obssp)) {  
      print (j)
      de <- obssp$depth[[j]]  # a variable for the observation depth layer
      yr <- (obssp$year[j])  # a variable for the observation year
      mth <- (obssp$month[j])  # a variable for the observation month
          if (brkyr == yr & brkmth == mth){
            obssp$salinity_surface[j] <- extract(x=temp_brick[[1]], y = obssp[j, ]) 
            if (is.na(de)){
              obssp$salinity_depth[j] <- NA
            } else  
              obssp$salinity_depth[j] <- extract(x=temp_brick[[de]], y = obssp[j, ])
          }
    }
}
```

```{r}
obssp$salinity_surface
```
above works!

Just play to see if you can get the variable thingy in....


```{r}
obs <- read.csv("../data/observations3.csv", header = TRUE) #change this path to your .csv location
#obs$month <- sprintf("%02d",obs$month) # new addition to add the 0 infront of single digit... test for seeing if you can match the netcdf name for year month selection of bricks
xy <- obs[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
obssp <- SpatialPointsDataFrame(coords = xy, data = obs, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
```

```{r}
netcdf_list <- list.files("../data/env/testnetcdf/salinity", pattern = '*.nc', full.names = TRUE) #true means the full path is included
no_netcdf <- length(netcdf_list) #for the loop - need to know how many files to cycle through
netcdf_name <- list.files("../data/env/testnetcdf/salinity", pattern = '*.nc', full.names = FALSE) #false means the path is not included
library (ncdf4)
for (i in 1:no_netcdf){  
  print(netcdf_name[i]) #this just prints the name of the netCDF R is working one
  brkyr <- as.integer(sapply(strsplit(netcdf_name[i], "_"), "[[", 1)) # extracting the first part of the netcdf filename (which is the year)
  brkmth <- as.integer(sapply(strsplit(netcdf_name[i], "_"), "[[", 2)) # extracting the second part of the netcdf filename (which is the month)
  brkvar <- (sapply(strsplit(netcdf_name[i], "_"), "[[", 3)) # extracting the third part of the netcdf (inc.nc)
  temp_brick <- brick(netcdf_list[i], lvar = 4)
  temp_brick <- projectRaster(temp_brick, aea) 
    for (j in 1:nrow(obssp)) {  
      print (j)
      de <- obssp$depth[[j]]  # a variable for the observation depth layer
      yr <- (obssp$year[j])  # a variable for the observation year
      mth <- (obssp$month[j])  # a variable for the observation month
          if (brkyr == yr & brkmth == mth & brkvar == "temp.nc"){
           
             obssp$temp_surface[j] <- extract(x=temp_brick[[1]], y = obssp[j, ]) 
              if (is.na(de)){
                obssp$temp_depth[j] <- NA
              } else  
                obssp$temp_depth[j] <- extract(x=temp_brick[[de]], y = obssp[j, ])
          } else if (brkyr == yr & brkmth == mth & brkvar == "salinity.nc") {
              obssp$salinity_surface[j] <- extract(x=temp_brick[[1]], y = obssp[j, ]) 
              if (is.na(de)){
                obssp$salinity_depth[j] <- NA
              } else  
                obssp$salinity_depth[j] <- extract(x=temp_brick[[de]], y = obssp[j, ]) 
          }
          } 
          }
    

```

```{r}
obssp$temp_depth
```


check temp


```{r}
nc1 <-  "../data/env/testnetcdf/salinity/1993_01_temp.nc" # change the file path to where ever your netcdfs are saved
row1rast <- brick(nc1,lvar = 4) #lvar = 4 is used because the netCDF contains four dimensions. Without this command, the raster brick will only have one level (the top one, which is my surface data)
row1rast <- projectRaster(row1rast, aea)
row1rast
nc2 <-  "../data/env/testnetcdf/salinity/1998_01_temp.nc" # change the file path to where ever your netcdfs are saved
row2rast <- brick(nc2,lvar = 4) #lvar = 4 is used because the netCDF contains four dimensions. Without this command, the raster brick will only have one level (the top one, which is my surface data)
row2rast <- projectRaster(row2rast, aea)
row2rast
nc3 <-  "../data/env/testnetcdf/salinity/1998_02_temp.nc" # change the file path to where ever your netcdfs are saved
row3rast <- brick(nc3,lvar = 4) #lvar = 4 is used because the netCDF contains four dimensions. Without this command, the raster brick will only have one level (the top one, which is my surface data)
row3rast <- projectRaster(row3rast, aea)
row3rast
```


```{r}
testrow1 <- read.csv("../data/row1.csv", header = TRUE)
#testrow1$month <- sprintf("%02d",testrow1$month)
testrow1xy <- testrow1[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow1sp <- SpatialPointsDataFrame(coords = testrow1xy, data = testrow1, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
testrow1sp
test15 <- extract(x=row1rast[[15]], y = testrow1sp)
test15
testrow2 <- read.csv("../data/row2.csv", header = TRUE)
#testrow2$month <- sprintf("%02d",testrow2$month)
testrow2xy <- testrow2[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow2sp <- SpatialPointsDataFrame(coords = testrow2xy, data = testrow2, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
testrow2sp
test22 <- extract(x=row2rast[[22]], y = testrow2sp)
test22
testrow3 <- read.csv("../data/row3.csv", header = TRUE)
#testrow3$month <- sprintf("%02d",testrow3$month)
testrow3xy <- testrow3[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow3sp <- SpatialPointsDataFrame(coords = testrow3xy, data = testrow3, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
testrow3sp
test17 <- extract(x=row3rast[[17]], y = testrow3sp)
test17
```






```{r}
testrow1.1 <- extract(x=row1rast[[1]], y = testrow1sp)
testrow1.1
testrow2.1 <- extract(x=row2rast[[1]], y = testrow2sp)
testrow2.1
testrow3.1 <- extract(x=row3rast[[1]], y = testrow3sp)
testrow3.1
```

yes! ok now for the bigger test...

```{r}
obs <- read.csv("../data/observationslong.csv", header = TRUE) #change this path to your .csv location
#obs$month <- sprintf("%02d",obs$month) # new addition to add the 0 infront of single digit... test for seeing if you can match the netcdf name for year month selection of bricks
xy <- obs[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
obssp <- SpatialPointsDataFrame(coords = xy, data = obs, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
```



```{r}
netcdf_list <- list.files("../data/env/testnetcdf/salinity", pattern = '*.nc', full.names = TRUE) #true means the full path is included
no_netcdf <- length(netcdf_list) #for the loop - need to know how many files to cycle through
netcdf_name <- list.files("../data/env/testnetcdf/salinity", pattern = '*.nc', full.names = FALSE) #false means the path is not included
library (ncdf4)
for (i in 1:no_netcdf){  
  print(netcdf_name[i]) #this just prints the name of the netCDF R is working one
  brkyr <- as.integer(sapply(strsplit(netcdf_name[i], "_"), "[[", 1)) # extracting the first part of the netcdf filename (which is the year)
  brkmth <- as.integer(sapply(strsplit(netcdf_name[i], "_"), "[[", 2)) # extracting the second part of the netcdf filename (which is the month)
  brkvar <- (sapply(strsplit(netcdf_name[i], "_"), "[[", 3)) # extracting the third part of the netcdf (inc.nc)
  temp_brick <- brick(netcdf_list[i], lvar = 4)
  temp_brick <- projectRaster(temp_brick, aea) 
    for (j in 1:nrow(obssp)) {  
      print (j)
      de <- obssp$depth[[j]]  # a variable for the observation depth layer
      yr <- (obssp$year[j])  # a variable for the observation year
      mth <- (obssp$month[j])  # a variable for the observation month
          if (brkyr == yr & brkmth == mth & brkvar == "temp.nc"){
           
             obssp$temp_surface[j] <- extract(x=temp_brick[[1]], y = obssp[j, ]) 
              if (is.na(de)){
                obssp$temp_depth[j] <- NA
              } else  
                obssp$temp_depth[j] <- extract(x=temp_brick[[de]], y = obssp[j, ])
          } else if (brkyr == yr & brkmth == mth & brkvar == "salinity.nc") {
              obssp$salinity_surface[j] <- extract(x=temp_brick[[1]], y = obssp[j, ]) 
              if (is.na(de)){
                obssp$salinity_depth[j] <- NA
              } else  
                obssp$salinity_depth[j] <- extract(x=temp_brick[[de]], y = obssp[j, ]) 
          }
          } 
          }
    

```

```{r}
obssp$temp_depth
```

checkt the temp

```{r}
test <- read.csv("../data/observationslong.csv", header = TRUE)
testrow1 <- test[1, ]
testrow1
#testrow1$month <- sprintf("%02d",testrow1$month)
testrow1xy <- testrow1[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow1sp <- SpatialPointsDataFrame(coords = testrow1xy, data = testrow1, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
test10 <- extract(x=row1rast[[10]], y = testrow1sp)
test10
testrow2 <- test[2, ]
#testrow2$month <- sprintf("%02d",testrow2$month)
testrow2xy <- testrow2[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow2sp <- SpatialPointsDataFrame(coords = testrow2xy, data = testrow2, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
test12 <- extract(x=row1rast[[12]], y = testrow2sp)
test12
testrow3 <- test[3, ]
testrow3xy <- testrow3[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow3sp <- SpatialPointsDataFrame(coords = testrow3xy, data = testrow3, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
testrow3sp
test40 <- extract(x=row3rast[[40]], y = testrow3sp)
test40
testrow4 <- test[4, ]
testrow4xy <- testrow4[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow4sp <- SpatialPointsDataFrame(coords = testrow4xy, data = testrow4, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
testrow4sp
test18 <- extract(x=row3rast[[18]], y = testrow4sp)
test18
testrow5 <- test[5, ]
testrow5xy <- testrow5[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow5sp <- SpatialPointsDataFrame(coords = testrow5xy, data = testrow5, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
test27 <- extract(x=row3rast[[27]], y = testrow5sp)
test27
testrow6 <- test[6, ]
testrow6xy <- testrow6[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow6sp <- SpatialPointsDataFrame(coords = testrow6xy, data = testrow6, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
test1 <- extract(x=row2rast[[1]], y = testrow6sp)
test1
testrow7 <- test[7, ]
testrow7xy <- testrow7[ ,c(4,5)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
testrow7sp <- SpatialPointsDataFrame(coords = testrow7xy, data = testrow7, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
test5 <- extract(x=row2rast[[5]], y = testrow7sp)
test5
```

```{r}
test1.1 <- extract(x=row1rast[[1]], y = testrow1sp)
test1.1
test2.1 <- extract(x=row1rast[[1]], y = testrow2sp)
test2.1
test3.1 <- extract(x=row3rast[[1]], y = testrow3sp)
test3.1
test4.1 <- extract(x=row3rast[[1]], y = testrow4sp)
test4.1
test5.1 <- extract(x=row3rast[[1]], y = testrow5sp)
test5.1
test6.1 <- extract(x=row2rast[[1]], y = testrow6sp)
test6.1
test7.1 <- extract(x=row2rast[[1]], y = testrow7sp)
test7.1
```
yes!!


full variables

```{r}
test <- read.csv("../data/looptest.csv", header = TRUE) #change this path to your .csv location
xy <- test[ ,c(18,19)] # This is to tell R where the coordinates are (in column 4 and 5). Note that the column order needs to be longitude, latitude
data_aea_sp <- SpatialPointsDataFrame(coords = xy, data = test, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")) # The CRS is used here is for the albers equal area projection.
```



```{r}

netcdf_list <- list.files("../data/env/netcdf", pattern = '*.nc', full.names = TRUE) #true means the full path is included
no_netcdf <- length(netcdf_list) #for the loop - need to know how many files to cycle through
netcdf_name <- list.files("../data/env/netcdf", pattern = '*.nc', full.names = FALSE) #false means the path is not includedCores
library (ncdf4)
library(sp)
library(rgdal)
for (i in 1:no_netcdf) {  
  library(raster)
  print(netcdf_name[i]) #this just prints the name of the netCDF R is working one
  brkyr <- as.integer(sapply(strsplit(netcdf_name[i], "_"), "[[", 1)) # extracting the first part of the netcdf filename (which is the year)
  brkmth <- as.integer(sapply(strsplit(netcdf_name[i], "_"), "[[", 2)) # extracting the second part of the netcdf filename (which is the month)
  brkvar <- (sapply(strsplit(netcdf_name[i], "_"), "[[", 3)) # extracting the third part of the netcdf (inc.nc)
  temp_brick <- brick(netcdf_list[i], lvar = 4)
  temp_brick <- projectRaster(temp_brick, aea) 
    for (j in 1:nrow(data_aea_sp)) {  
      de <- data_aea_sp$depthlayerno[[j]]  # a variable for the observation depth layer
      yr <- (data_aea_sp$year[j])  # a variable for the observation year
      mth <- (data_aea_sp$month[j])  # a variable for the observation month
          if (brkyr == yr & brkmth == mth & brkvar == "temp.nc"){
              data_aea_sp$temp_surface[j] <- extract(x=temp_brick[[1]], y = data_aea_sp[j, ]) 
              if (is.na(de)){
                data_aea_sp$temp_depth[j] <- NA
              } else  
                data_aea_sp$temp_depth[j] <- extract(x=temp_brick[[de]], y = data_aea_sp[j, ])
          } else if (brkyr == yr & brkmth == mth & brkvar == "salinity.nc") {
              data_aea_sp$salinity_surface[j] <- extract(x=temp_brick[[1]], y = data_aea_sp[j, ]) 
              if (is.na(de)){
                data_aea_sp$salinity_depth[j] <- NA
              } else  
                data_aea_sp$salinity_depth[j] <- extract(x=temp_brick[[de]], y = data_aea_sp[j, ]) 
          } else if (brkyr == yr & brkmth == mth & brkvar == "chl.nc") {
              data_aea_sp$chl_surface[j] <- extract(x=temp_brick[[1]], y = data_aea_sp[j, ]) 
              if (is.na(de)){
                data_aea_sp$chl_depth[j] <- NA
              } else  
                data_aea_sp$chl_depth[j] <- extract(x=temp_brick[[de]], y = data_aea_sp[j, ]) 
          } else if (brkyr == yr & brkmth == mth & brkvar == "o2.nc") {
              data_aea_sp$o2_surface[j] <- extract(x=temp_brick[[1]], y = data_aea_sp[j, ]) 
              if (is.na(de)){
                data_aea_sp$o2_depth[j] <- NA
              } else  
                data_aea_sp$o2_depth[j] <- extract(x=temp_brick[[de]], y = data_aea_sp[j, ]) 
          } else if (brkyr == yr & brkmth == mth & brkvar == "mlp.nc") {
              data_aea_sp$mlp_surface[j] <- extract(x=temp_brick[[1]], y = data_aea_sp[j, ])
          } else if (brkyr == yr & brkmth == mth & brkvar == "ssh.nc") {
              data_aea_sp$ssh_surface[j] <- extract(x=temp_brick[[1]], y = data_aea_sp[j, ]) 
            
          }
     
    }
}

```

```{r}
data_aea_sp$mlp_surface
data_aea_sp$salinity_depth
data_aea_sp$o2_surface
```

```{r}
str(data_aea)
```

```{r}
str(obs)
```

