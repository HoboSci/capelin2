---
title: "timesliced_random_cell_selection"
author: "Samantha Andrews"
output: html_notebook
---

# Overview
Preperation of the capelin (*Mallotus villosus*) data obtained from [OBIS](www.iobis.org). This database shows the global occurance of capelin. 

A note to anyone who might happen to stumble across this... I am a beginner in R and have had no exposure to similar languages. I don't know what I'm doing. The code herein is unlikely to be elegant and there area probably more efficient ways of running the code.

Built with 'r getRversion()'.

# Package dependencies
You can load them using the following code which uses a function called [ipak](https://gist.github.com/stevenworthington/3178163). 
Note this function checks to see if the packages are installed first.
Th
```{r pre-install packages, message=FALSE}
packages <- c("raster", "dplyr")
source("../src/ipak.R")
ipak(packages)
suppressMessages(ipak)
```

you have a unique_cell raster already (glo_unique_cell) (output/env/glo_unique_cell.tif)

```{r}
plot(glo_unique_cell)
```

as a reminder, how many cells are there?
```{r}
glo_unique_cell
```

6729...

ok now you want to generate a centroid for each cell... (a point in the center of each cell)
use the raster layer to 1) transfer the raster into a dataframe, with the values (cell numbers) linked to each centroid with xy coordinates (note as the raster is an aea projection, the xy will be in meters)
```{r}
library(raster)
unique_cell_centroid <- as.data.frame(glo_unique_cell, row.names = NULL, optional = FALSE, xy = TRUE, centroids = TRUE, na.rm = TRUE)
names(unique_cell_centroid)[names(unique_cell_centroid)=="layer.1"] <- "cell_id" #just renames the output
names(unique_cell_centroid)[names(unique_cell_centroid)=="x"] <- "longitude" #just renames the output
names(unique_cell_centroid)[names(unique_cell_centroid)=="y"] <- "latitude" #just renames the output
write.csv(unique_cell_centroid, "../output/env/unique_cell_centroid.csv")
plot(glo_unique_cell)
points(unique_cell_centroid$longitude, unique_cell_centroid$latitude, pch = 10, col = "black")
```
well... the plot doesn't tell me much... but i definately have points!

ok so now I have a base list to work off... This gives you a dataset of xy points, but you need xyz (where z is based on the depth layers in the environmental data)
```{r}
unique_cell_xyz <- unique_cell_centroid
unique_cell_xyz$depthlayerno <- NA
unique_cell_xyz <- unique_cell_xyz[rep(seq_len(nrow(unique_cell_xyz)), each=50),] #this generates 50 repetitions of each row
unique_cell_xyz$depthlayerno <- rep(1:50) #assign 1:50 on a repeating cycle to the depth column. 50 is chosen because there are 50 depth layers
unique_cell_xyz$id_depth <- paste(unique_cell_xyz$cell_id, unique_cell_xyz$depthlayerno, sep="") #create a new column that is a unique cell_id & depth ID. This is to help remove cells later and randomise
```

Split the data_aea into timeslices (year/month).
All you need is the year, month, cell_id, and depthlayerno
```{r}
cell_yymm <- subset(data_aea, select= c(cell_id, depthlayerno, year, month)) #create a new df with just cell_id, yr, month
cell_yymm$id_depth <- paste(cell_yymm$cell_id, cell_yymm$depthlayerno, sep="") #create a new column that is a unique cell_id & depth ID. This is to help remove cells later and randomise
split_cell_yymm <- split(cell_yymm, list(cell_yymm$year, cell_yymm$month), drop = TRUE)
```


What I want to do is for each time slice, create a list of all cells (xyz), then remove the ones where observations occuredand create a .csv with the name of the level being worked on

Here is a loop to create a copy of the unique_cell_centroid dataframe, and give it the same name as the splitobs_cell_yymm level
.csv naming code courtesy of [nadizan/stack exchange](https://stackoverflow.com/questions/53045158/r-naming-csv-with-a-list-level-name-in-a-loop?noredirect=1#comment92990285_53045158)


```{r timesliced unique unsampled}
no_timeslices <- length(split_cell_yymm) # how many levels (time slices) are in the list
bckoutput <- "../output/bio/background/raw/" #where the files are to be saved to
for (i in 1:no_timeslices){
  timeslice <- split_cell_yymm[[i]]
  timeslice <- as.data.frame(timeslice)
  time_cell <- unique_cell_xyz
  time_cell <- time_cell[!time_cell$id_depth %in% timeslice$id_depth, , drop = FALSE]
  write.csv(time_cell, paste0(bckoutput, names(lapply(split_cell_yymm, names))[i], ".csv"), row.names = FALSE) 
}
```

Ok so now I have a bunch of .csv files containing cells where no observations occurred for a given timeslice on xyz coordinates.
Next step is to randomly select cells in each timeslice. Make sure you generate new files for each...

load the .csvs... [code](https://www.reed.edu/data-at-reed/software/R/reading_and_writing.html)

```{r}
library(dplyr)
bckrnd_folder <- "../output/bio/background/raw/"      # path to folder that holds multiple .csv files
bckrnd_list <- list.files(path = bckrnd_folder, pattern="*.csv") # create list of all .csv files in folder
randbckoutput <- "../output/bio/background/rand/" #where the files are to be saved to
# read in each .csv file in file_list and create a data frame with the same name as the .csv file
for (i in 1:length(bckrnd_list)){
  test_sel <- read.csv(paste(bckrnd_folder, bckrnd_list[i], sep=''))
  test_sel <- sample_n(test_sel, 10000) #where 10000 = number of rows to sample (large sample as per maxent)
  write.csv(test_sel, file = paste0(randbckoutput, bckrnd_list[i]), row.names = FALSE) #dont need to add .csv as it's already in the filename
}
  
```

ok now i have a ton of files for random background points broken into timeslices. I'd like to add a colum for year and one for month to each of these datasets. They should be populated based on the name of the file (e.g. 1998.4.csv would have year = 1998 and month = 4)

```{r}

```

