---
title: "timesliced_random_cell_selection"
author: "Samantha Andrews"
output: html_notebook
---

# Overview
Preperation of the capelin (*Mallotus villosus*) data obtained from [OBIS](www.iobis.org). This database shows the global occurance of capelin. 

A note to anyone who might happen to stumble across this... I am a beginner in R and have had no exposure to similar languages. I don't know what I'm doing. The code herein is unlikely to be elegant and there area probably more efficient ways of running the code.

Built with 'r getRversion()'.

# Package dependencies
You can load them using the following code which uses a function called [ipak](https://gist.github.com/stevenworthington/3178163). 
Note this function checks to see if the packages are installed first.
Th
```{r pre-install packages, message=FALSE}
packages <- c("raster", "dplyr", "data.table", "sp")
source("../src/ipak.R")
ipak(packages)
suppressMessages(ipak)
```

# the show
you have a unique_cell raster already (glo_unique_cell) (output/env/glo_unique_cell.tif)

```{r}
plot(glo_unique_cell)
```

as a reminder, how many cells are there?
```{r}
glo_unique_cell
```

6729...

ok now you want to generate a centroid for each cell... (a point in the center of each cell)
use the raster layer to 1) transfer the raster into a dataframe, with the values (cell numbers) linked to each centroid with xy coordinates (note as the raster is an aea projection, the xy will be in meters)
```{r}
library(raster)
unique_cell_centroid <- as.data.frame(glo_unique_cell, row.names = NULL, optional = FALSE, xy = TRUE, centroids = TRUE, na.rm = TRUE)
names(unique_cell_centroid)[names(unique_cell_centroid)=="layer.1"] <- "cell_id" #just renames the output
names(unique_cell_centroid)[names(unique_cell_centroid)=="x"] <- "longitude" #just renames the output
names(unique_cell_centroid)[names(unique_cell_centroid)=="y"] <- "latitude" #just renames the output
write.csv(unique_cell_centroid, "../output/env/unique_cell_centroid.csv")
plot(glo_unique_cell)
points(unique_cell_centroid$longitude, unique_cell_centroid$latitude, pch = 10, col = "black")
```
well... the plot doesn't tell me much... but i definately have points!

ok so now I have a base list to work off... This gives you a dataset of xy points, but you need xyz (where z is based on the depth layers in the environmental data)
```{r}
unique_cell_xyz <- unique_cell_centroid
unique_cell_xyz$depthlayerno <- NA
unique_cell_xyz <- unique_cell_xyz[rep(seq_len(nrow(unique_cell_xyz)), each=50),] #this generates 50 repetitions of each row
unique_cell_xyz$depthlayerno <- rep(1:50) #assign 1:50 on a repeating cycle to the depth column. 50 is chosen because there are 50 depth layers
unique_cell_xyz$id_depth <- paste(unique_cell_xyz$cell_id, unique_cell_xyz$depthlayerno, sep="") #create a new column that is a unique cell_id & depth ID. This is to help remove cells later and randomise
```

Split the data_aea into timeslices (year/month).
All you need is the year, month, cell_id, and depthlayerno
```{r}
cell_yymm <- subset(data_aea, select= c(cell_id, depthlayerno, year, month)) #create a new df with just cell_id, yr, month
cell_yymm$id_depth <- paste(cell_yymm$cell_id, cell_yymm$depthlayerno, sep="") #create a new column that is a unique cell_id & depth ID. This is to help remove cells later and randomise
split_cell_yymm <- split(cell_yymm, list(cell_yymm$year, cell_yymm$month), drop = TRUE)
```


What I want to do is for each time slice, create a list of all cells (xyz), then remove the ones where observations occuredand create a .csv with the name of the level being worked on

Here is a loop to create a copy of the unique_cell_centroid dataframe, and give it the same name as the splitobs_cell_yymm level
.csv naming code courtesy of [nadizan/stack exchange](https://stackoverflow.com/questions/53045158/r-naming-csv-with-a-list-level-name-in-a-loop?noredirect=1#comment92990285_53045158)


```{r timesliced unique unsampled}
no_timeslices <- length(split_cell_yymm) # how many levels (time slices) are in the list
bckoutput <- "../output/bio/background/raw/" #where the files are to be saved to
for (i in 1:no_timeslices){
  timeslice <- split_cell_yymm[[i]]
  timeslice <- as.data.frame(timeslice)
  time_cell <- unique_cell_xyz
  time_cell <- time_cell[!time_cell$id_depth %in% timeslice$id_depth, , drop = FALSE]
  write.csv(time_cell, paste0(bckoutput, names(lapply(split_cell_yymm, names))[i], ".csv"), row.names = FALSE) 
}
```

Ok so now I have a bunch of .csv files containing cells where no observations occurred for a given timeslice on xyz coordinates.
Next step is to randomly select cells in each timeslice. Make sure you generate new files for each...

load the .csvs... [code](https://www.reed.edu/data-at-reed/software/R/reading_and_writing.html)

```{r}
library(dplyr)
bckrnd_folder <- "../output/bio/background/raw/"      # path to folder that holds multiple .csv files
bckrnd_list <- list.files(path = bckrnd_folder, pattern="*.csv") # create list of all .csv files in folder
randbckoutput <- "../output/bio/background/rand/" #where the files are to be saved to
# read in each .csv file in file_list and create a data frame with the same name as the .csv file
for (i in 1:length(bckrnd_list)){
  sel <- read.csv(paste(bckrnd_folder, bckrnd_list[i], sep=''))
  sel <- sample_n(test_sel, 10000) #where 10000 = number of rows to sample (large sample as per maxent)
  write.csv(sel, file = paste0(randbckoutput, bckrnd_list[i]), row.names = FALSE) #dont need to add .csv as it's already in the filename
}
  
```

ok now i have a ton of files for random background points broken into timeslices. I'd like to add a colum for year and one for month to each of these datasets. They should be populated based on the name of the file (e.g. 1998.4.csv would have year = 1998 and month = 4)

```{r}
rand_folder <- "../output/bio/background/rand/"      # path to folder that holds multiple .csv files
rand_list <- list.files(path = rand_folder, pattern="*.csv") # create list of all .csv files in folder
randbckoutput <- "../output/bio/background/rand/" #where the files are to be saved to
for(i in 1:length(rand_list)){
  randtemp <- read.csv(paste(rand_folder, rand_list[i], sep=''))
  randtemp$year <- substr(rand_list[i], 1, 4) #the year is characters 1-4 in the filename
  randtemp$month <- substr(rand_list[i], 6, 7) #the month is characters 6 & 7 in the filename (except where the month is a single digit)
  write.csv(randtemp, file = paste0(randbckoutput, bckrnd_list[i]), row.names = FALSE) #dont need to add .csv as it's already in the filename
}
```
note that in the output temp file in R shows a . after the month if that month is a single digit. The .csv outputs don't 

# populating the background points data with... data

ok now you can start to populate the rest of the background point information. The background points file should mirror as much as possible the occurence file. Maybe it would be best to merge the files together, and them split them again later? would save looping everything to repeat the process through multiple files...

```{r}
library(data.table)
filenames  <- list.files(path = rand_folder, pattern="*.csv", full.names = TRUE) 
background_all <- rbindlist(lapply(filenames,fread))
write.csv(background_all, "../output/bio/background_all.csv", row.names = FALSE)
```


get the columns from the occurence data so you know what to add
```{r}
occ_column <- colnames(data_aea)
occ_column
```

ok so have cell_id, year, month, decimalLongitude.1(meters - in background_all its longitude), decimalLatitude.1 (meters - in background_all its latitude), depth_layer_no.

Easy first one - add an id based on id_depth
```{r}
background_all$id <- background_all$id_depth
write.csv(background_all, "../output/bio/background_all.csv", row.names = FALSE)
```

ok lets's get the real decimalLatitude and decimalLongitude.
Will need to plot all point, extract the lonlat coordinates

1) load the file as a spatialdatapointframe. give it the aea coordinate

```{r}
library(sp)
xy <- background_all[ ,c(1,2)] #lon lat in col 1 and 2
sp_background <- SpatialPointsDataFrame(coords = xy, data = background_all, proj4string = CRS("+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs"))
head(sp_background)
```
```{r}
plot(sp_background)
```

2) reproject to a wgs

```{r}
sp_background <- spTransform(sp_background, CRS = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")
plot(sp_background)
```
3) extract lonlat, add to dataframe

```{r}
head(sp_background)
```



save as csv



