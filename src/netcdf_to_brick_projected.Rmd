---
title: "netcdf_to_brick_projected"
author: "Samantha Andrews"
output: html_notebook
---

# Overview
Mass netCDF to raster brick, and then reprojection...

A note to anyone who might happen to stumble across this... I am a beginner in R and have had no exposure to similar languages. I don't know what I'm doing. The code herein is unlikely to be elegant and there area probably more efficient ways of running the code.

SAM - YOU MIGHT WANT TO [PARALLEL PROCESS FOR THE WHOLE DATASET..](https://cran.r-project.org/web/packages/doParallel/vignettes/gettingstartedParallel.pdf) and also [here](https://gis.stackexchange.com/questions/253618/r-multicore-approach-to-extract-raster-values-using-spatial-points)

Built with 'r getRversion()'.

# Package dependencies
You can load them using the following code which uses a function called [ipak](https://gist.github.com/stevenworthington/3178163). 
Note this function checks to see if the packages are installed first.

```{r pre-install packages, message=FALSE}
packages <- c("ncdf4", "sp")
source("../src/ipak.R")
ipak(packages)
suppressMessages(ipak)
```

Ok first get a list of netcdfs in the folder...
```{r}
netcdf_list <- list.files("../data/env/netcdf", pattern = '*.nc', full.names = TRUE)
```

ok now create a raster brick for each netcdf, project, and assing the same file name as the netCDF

```{r}
no_netcdf <- length(netcdf_list) #for the loop - need to know how many files to cycle through
netcdf_name <- list.files("../data/env/netcdf", pattern = '*.nc', full.names = FALSE) #false means the path is not included
library (ncdf4)
for (i in 1:no_netcdf) {
  print(netcdf_name[i]) #this just prings the name of the netCDF R is working on
  temp_brick <- brick(netcdf_list[i], lvar = 4)
  temp_brick <- projectRaster(temp_brick, aea) #aea is an existing raster in the projection I want that I created (environmental_data_preperation)
  assign(netcdf_name[i], temp_brick) #this asigns the netCDF name to the raster brick
}

```
just a quick test....

```{r}
`1998_01_salinity.nc`
plot(`1998_01_salinity.nc` [[8]])
```

Look up year and month in the occurence data (data_aea)
year = data_aea$year
month = data_aea$month

the raster brick file names are 
character 1:4 = year
charcater 6:7 = month
character 9:end = env. variable name


maybe start by splitting the occurence data into year-month? Then you can search for the rasters without going through everything....
```{r}
library(sp)
species_obs_date <- SpatialPointsDataFrame(coords = xy, data = data_aea, proj4string = CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")) #convert into a spatialpoints dataframe to do the extraction
species_obs_date <- spTransform(species_obs_date, CRS = "+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs") #need to reproject.... note -60 used to be -91. Changed to 'straighten up'
split_obs <- split(species_obs_date, paste(species_obs_date$year, species_obs_date$month))
```

just check the species_obs_date complete file in a plot
```{r}
plot(species_obs_date)
```
looks good...

```{r}
for(i in split_obs){
  print(i)
}
```


hmm what now....

You want to populate the following fields in the species_obs_date spatialdf
mlp
salinty_1
salinity_depth
ssh
temp_1
temp_depth
chl_1
chl_depth
o2_1
o2_depth

where _1 indicates the surface layer [[1]] and depth is == depthlayerno
Note mlp and ssh have only one single layer ([[1]])


netcdf_list = list of all netcdfs
no_netcdf = number of netcdfs created
netcdf_name = name of netcdfs - will match the name of the raster bricks too.


```{r}



```




