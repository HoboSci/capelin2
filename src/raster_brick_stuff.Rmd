---
title: "raster_brick_stuff"
author: "Samantha Andrews"
output: html_notebook
---

# Overview
Creating a way to automate mass raster_brick creation, with unique names...


A note to anyone who might happen to stumble across this... I am a beginner in R and have had no exposure to similar languages. I don't know what I'm doing. The code herein is unlikely to be elegant and there area probably more efficient ways of running the code.

Built with 'r getRversion()'.

# Package dependencies
You can install and load them using the following code which uses a function called [ipak](https://gist.github.com/stevenworthington/3178163). 
Note this function checks to see if the packages are installed first. If they are not installed, it will do so before loading
```{r pre-install packages, suppressMessages(expr)}
packages <- c("rgdal", "raster", "ncdf4", "RNetCDF", "sp", "parallel", "magrittr", "data.table") 
source("../src/ipak.R")
ipak(packages)
```

Note that the original files have been renamed using Windows Powershell. See OneNote document for coding details. All files are now in the following format:

yyyy_mm_variablename.nc 

where variablename is all alpha characters, but varies in length. E.G. 1993_01_mlp.nc

For the parallel computing (this will make things faster), detect cores automatically (leave one free though).
```{r}
cores <- detectCores() - 1
```


Tell R where to find your data and where to spit out the output
```{r data_paths}
weatherraster_path <- "../data/env/netcdftest"
countryshape_path <- "./output/env"
output_path <- "../output/env/nctest"
```

# ---- 1. Define Functions.

# -- 1.A. Define Small Subfunctions.

Small function 1) Reads filename & explicitly opens it as a NetCDF file.
```{r}
open_netcdf_as_rasterbrick <- function( ncdf_filename_input ) {
  ncdf_filename_input %>%
  file.path( weatherraster_path , . ) %>%
  nc_open( . )  %>%  # Open path as NetCDF file.
  ncvar_get( . ) %>%  # Get NetCDF file.
  brick( . ) %>%
  return( . )
}
```

# Small function 2) Transforms the raster brick to our country shapefile.
```{r}
match_rainbrick_to_countryshape <- function( brick_input ) {
  brick_input %>%
  # Reproject raster brick to the shapefile's coordinate system.
  projectRaster( . , crs = proj4string( country_shapefile ), method = "ngb" ) %>%
  return( . )
}
```


# Small function 3) Extract data from a raster brick.
```{r}
generate_data_from_rasterandshape <- function( brick_input ) {
	brick_input %>%
    raster::extract( . , countryshape , TRUE, fun = mean, na.rm = TRUE  )
    return( . )
}
```

# Small function 4) Grab 4-digit year from input filename.
```{r}
grab_year_from_inputfile <- function( ncdf_filename_input ) {
  ncdf_filename_input %>%
  regexpr("[0-9]+", . ) %>%  # Match 4-digit year.
  regmatches( ncdf_filename_input , . ) %>%  # Get matched REGEX from input string.
  return( . )
}
```

# --- 1.B. Define "BIG" Function That Extracts Dataset From a NetCDF File.
```{r}
generate_datatable_from_rasterbricks <- function( ncdf_filename_input ) {
	ncdf_filename_input %>%
	open_netcdf_as_rasterbrick( . ) %>%
	match_rainbrick_to_countryshape( . ) %>%
	generate_data_from_rasterandshape( . ) -> country_means_dataframe
	ncdf_filename_input %>%
	grab_year_from_inputfile( ) %>%
	write.csv( country_means_dataframe ,
				file = file.path( . , output_path ) )
}
```

# ---- 2. Main Code: Setup Environment to Run Big Function.

Start with your name of the country shapefile we're referencing.
```{r}
"poly.shp" %>%
file.path(countryshape_path) %>%
readODG( den = .  , layer = "FID" ) -> countryshape
raster_file_list <- list.files( path = weatherraster_path ,
pattern = ".nc" , all.files = FALSE , full.names = FALSE )
```

Generate list of NetCDF files automatically from our directory.
Match all files ending in ".nc"
```{r}
raster_file_list <- list.files( path = weatherraster_path ,
pattern = ".nc" , all.files = FALSE , full.names = FALSE )
```


Run our big function on the list of NetCDF files.
```{r}
mclapply( raster_file_list , generate_datatable_from_rasterbricks )
```

# ---- 3. Assemble .CSV Files using Data.Table and Lapply.

Fetch all files ending in .CSV in out output path.
```{r}
csv_file_list <- list.files( path = output_path ,
                             pattern = ".csv",
                             all.files = FALSE,
                             full.names = TRUE,
                             recursive = FALSE )
lapply( csv_file_list , fread , sep = "," ) %>%
rbindlist( . ) -> big_datatable
write.csv( big_datatable, file = file.path( output_path , "big_file_name.csv") )
```


# !!!!!

```{r}
b <- nc_open("../data/env/netcdftest/1993_01_salinity.nc")
b
c <- brick(b, lvar = 4)
c
pts <- data_aea
ts <- extract(c, cbind(pts$decimalLongitude, pts$decimalLatitude))
```


```{r}
brickttest <- nc_open("../data/env/netcdftest/1993_01_salinity.nc")
testbrick <- brick( "../data/env/netcdftest/1993_01_salinity.nc", lvar = 4)


```

