---
title: "environmental_data_preperation"
author: "Samantha Andrews"
output: html_notebook
---

# Overview
Preperation of GLORYS and BIOMER netCDFs obtained from [Copernicus](www.marine.copernicus.eu/services-portfolio/access-to-products/). These databases give global oceanographic conditions.
The BIOMER datasets are in netCDF version 3, and the GLORYS in netCDF version 1

A note to anyone who might happen to stumble across this... I am a beginner in R and have had no exposure to similar languages. The code herein is unlikely to be elegant and there is likely more efficient ways of running the code.

Built with 'r getRversion()'.

# Package dependencies
You can load them using the following code which uses a function called [ipak](https://gist.github.com/stevenworthington/3178163). 
Note this function checks to see if the packages are installed first.
```{r pre-install packages, message=FALSE}
packages <- c("raster", "rgdal") 
source("../src/ipak.R")
ipak(packages)
```


# read in a netcdf
```{r}
library("ncdf4")
ncbr <- brick("../data/env/CMEMS_GLOBAL_REANALYSIS_PHY_001_025_salinity_monthly_mean_1993-01.nclonlat.ncdepthtrim.nc")
ncbr
```

# reproject 
There is currently an issue with the projectRaster command in the raster package. Michael Sumners kindly offered a [temporary solution](https://twitter.com/mdsumner/status/1040500830539935744)
```{r}
## use ncdf4 directly
library(ncdf4)
## connection to the file
nc <- nc_open("../data/env/CMEMS_GLOBAL_REANALYSIS_PHY_001_025_salinity_monthly_mean_1993-01.nclonlat.ncdepthtrim.nc")
## desired variable 
v <- ncvar_get(nc, "salinity")
## dimension coordinates
lon <- ncvar_get(nc, "longitude")
lat <- ncvar_get(nc, "latitude")
## a template, one map from the lon, lat, and v[,,1]
template <- raster(list(x = lon, y = lat, z = v[,,1]), crs = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 ")

## apply template to brick, and set values to v (but flipped in Y because that's how raster works - lat is increasing in the NetCDF, so we go upside down)
diy <- setValues(brick(template), v[, ncol(v):1, ])

## target
prj <- "+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs" #note -60 used to be -91. Changed to 'straighten up'.
target <- projectExtent(diy, prj)  ## get a target extent, and we'll set the exact resolution we want
res(target) <- c(25000, 25000)
aea <- projectRaster(diy, target)
plot(aea[[1]]) #the number in brackets refers to the depth number
aea
writeRaster(aea[[1]],'../data/env/aea.tif',overwrite=TRUE,options=c('TFW=YES'))
```


#if projectRaster woudl work properly...

library(raster)
canada_eq_ar_proj <- "+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=- +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs"
library("rgdal")
rp <- projectRaster(ncbr, crs = canada_eq_ar_proj)
rp
writeRaster(rp,'../data/env/rp.tif',options=c('TFW=YES')) #this last line jsut saves as a tiff...don't really nead this

----------

#create unique id layer
ok now you want to create a duplicate of the top layer and then give each cell an unique ID

First 
```{r}
aea[[1]]
unique_cell <- (aea[[1]])
```

Because the NA values are currently attributed with some other number and not NA in R (NA is set to -32767 in this particular layer), you need to make sure to exclude the cells which represent NA... so anything under 0.
the cell id will be a count of the cells with data. First calculate how many cells to remove from ncell (11,425)
```{r}
cell_val_freq <- freq(unique_cell, value=NULL)
cell_val_freq
```
ok so we have 4693 cells that have NA (or in reality a negative number that represents NA). so remove 4693 from ncell. We know that there are 11424 cells, soo... 11424-4693 = 6732 cells have data.

now give a unique ID to each cell
```{r}
unique_cell[unique_cell > 0] <- 1:6731
writeRaster(unique_cell,'../output/env/unique_cell.tif',overwrite=TRUE, options=c('TFW=YES')) #so you can access it again
```

Done!

-----------------------------------------






