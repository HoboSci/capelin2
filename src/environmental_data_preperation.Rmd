---
title: "environmental_data_preperation"
author: "Samantha Andrews"
output: html_notebook
---

# Overview
Preperation of GLORYS and BIOMER netCDFs obtained from [Copernicus](www.marine.copernicus.eu/services-portfolio/access-to-products/). These databases give global oceanographic condition.
UPDATE: also includes prep of the AMO and NAO data...


A note to anyone who might happen to stumble across this... I am a beginner in R and have had no exposure to similar languages. The code herein is unlikely to be elegant and there is likely more efficient ways of running the code.

Built with 'r getRversion()'.

# Package dependencies
You can load them using the following code which uses a function called [ipak](https://gist.github.com/stevenworthington/3178163). 
Note this function checks to see if the packages are installed first.
```{r pre-install packages, message=FALSE}
packages <- c("ncdf4", "raster", "rgdal", "useful") 
source("../src/ipak.R")
ipak(packages)
```

# NetCDFs (Biomer and GLORYS)
read in a netcdf
note this is a GLORYS dataset
```{r}
library("ncdf4")
ncbr <- brick("../data/env/CMEMS_GLOBAL_REANALYSIS_PHY_001_025_salinity_monthly_mean_1993-01.nclonlat.ncdepthtrim.nc")
ncbr
```

reproject ...
There is currently an issue with the projectRaster command in the raster package. Michael Sumners kindly offered a [temporary solution](https://twitter.com/mdsumner/status/1040500830539935744)
```{r}
## use ncdf4 directly
library(ncdf4)
## connection to the file
nc <- nc_open("../data/env/CMEMS_GLOBAL_REANALYSIS_PHY_001_025_salinity_monthly_mean_1993-01.nclonlat.ncdepthtrim.nc")
## desired variable 
v <- ncvar_get(nc, "salinity")
## dimension coordinates
lon <- ncvar_get(nc, "longitude")
lat <- ncvar_get(nc, "latitude")
## a template, one map from the lon, lat, and v[,,1]
template <- raster(list(x = lon, y = lat, z = v[,,1]), crs = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 ")

## apply template to brick, and set values to v (but flipped in Y because that's how raster works - lat is increasing in the NetCDF, so we go upside down)
diy <- setValues(brick(template), v[, ncol(v):1, ])

## target
prj <- "+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=-60 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs" #note -60 used to be -91. Changed to 'straighten up'.
target <- projectExtent(diy, prj)  ## get a target extent, and we'll set the exact resolution we want
res(target) <- c(25000, 25000)
aea <- projectRaster(diy, target)
plot(aea[[1]]) #the number in brackets refers to the depth number
aea
writeRaster(aea[[1]],'../output/env/aea.tif',overwrite=TRUE,options=c('TFW=YES'))
```


if projectRaster would work properly...


library(raster)
canada_eq_ar_proj <- "+proj=aea +lat_1=50 +lat_2=70 +lat_0=40 +lon_0=- +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs"
library("rgdal")
rp <- projectRaster(ncbr, crs = canada_eq_ar_proj)
rp
writeRaster(rp,'../data/env/rp.tif',options=c('TFW=YES')) 



----------

# create unique id layer
ok now you want to create a duplicate of the top layer and then give each cell an unique ID

First 
```{r}
aea[[1]]
unique_cell <- (aea[[1]])
```

Because the NA values are currently attributed with some other number and not NA in R (NA is set to -32767 in this particular layer), you need to make sure to exclude the cells which represent NA... so anything under 0.
the cell id will be a count of the cells with data. First calculate how many cells to remove from ncell (11,424)
```{r}
cell_val_freq <- freq(unique_cell, value=NULL)
cell_val_freq
```
ok so we have 4693 cells that have NA (or in reality a negative number that represents NA). so remove 4693 from ncell. We know that there are 11424 cells, soo... 11424-4693 = 6731 cells have data.

now give a unique ID to each cell
```{r}
unique_cell[unique_cell > 0] <- 1:6731 
writeRaster(unique_cell,'../output/env/unique_cell.tif',overwrite=TRUE, options=c('TFW=YES')) #so you can access it again
```

Done!

-----------------------------------------
# The Biomer Layers...

ok so that unique cell layer was built from a GLORYS layer... in the biomer layer needs to match to this layer (and i have reason to think that it does not - the biomer layer was converted by me from an ORCA025 grid, and IIRC when I looked at the layers in ArcGIS there were some differences in the cell boundaries)

read in a biomer netcdf
```{r}
library("ncdf4")
biobrick <- brick("../data/env/CMEMS_GLOBAL_REANALYSIS_BIO_001_018_chl_monthly_mean_1998-01.ncwgs.nc_lonlat.ncdepthtrim.nc")
biobrick
```

Project the biomer file to match the glorys layer
```{r}
bio_aea <- projectRaster(biobrick, aea) #note this only projects the top layer
bio_aea
writeRaster(bio_aea,'../output/env/bio_aea.tif',overwrite=TRUE, options=c('TFW=YES')) #so you can access it again
```

plot
```{r}
plot(bio_aea)
```
ok now lets do the same "create unique cell ID" process for the biomer layer as you did for GLORYS. You want to check they match

Because the NA values are currently attributed with some other number and not NA in R (NA is set to -32767 in this particular layer), you need to make sure to exclude the cells which represent NA... so anything under 0.
the cell id will be a count of the cells with data. First calculate how many cells to remove from ncell (11,424) 
```{r}
bio_unique_cell <- bio_aea
bio_cell_val_freq <- freq(bio_unique_cell, value=NULL)
bio_cell_val_freq
```
ok so we have 4695 cells that have NA. Note that the GLORYS layer has 4693 NA cells....  a quick visual inspection with ArcGIS reveals one cell likes off the coast of the USA south of Nova Scotia (unique cell ID 4840) and one off the north tip of Nova Scotia (unique cell ID 3438)
so remove 4840 from ncell. We know that there are 11424 cells, soo... 11424-4695 = 6729 cells have data.

you need to remove cell 3438 and 4695 from the Glorys unique cell layer....
```{r}
values(unique_cell)[values(unique_cell) == 3438] = NA
values(unique_cell)[values(unique_cell) == 4840] = NA
```

look at the number of NAs again...
```{r}
uc_na <- freq(unique_cell,value=NA)
uc_na
```

ok great. ok so now give a unique ID to each BIOMER cell
```{r}
bio_unique_cell[bio_unique_cell > -1] <- 1:6729 
writeRaster(bio_unique_cell,'../output/env/bio_unique_cell.tif',overwrite=TRUE, options=c('TFW=YES')) #so you can access it again
bio_unique_cell
```
now give a unique ID to the GLORYS layer with the cells removed...
```{r}
glo_unique_cell <- unique_cell
glo_unique_cell[glo_unique_cell > -1] <- 1:6729 
writeRaster(glo_unique_cell,'../output/env/glo_unique_cell.tif',overwrite=TRUE, options=c('TFW=YES')) #so you can access it again
bio_unique_cell
```

and done (again)


-------------------------------------------

# AMO data 

Downloaded from [NOAA](https://www.esrl.noaa.gov/psd/data/timeseries/AMO/) (AMO, unsmoothed, short) as a txt and then converted to a .csv

load raw data
```{r}
amoraw <- read.csv("../data/env/amon.us.data.csv", header = FALSE) 
head(amoraw)
```
ok first col = year, the others represent the month. Give the columns some proper names
```{r}
colnames(amoraw) <- c("year","Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")
head(amoraw)
```

The data downloaded from the site indidcated that NA values are represented by -99.99. Lets replace those values with NA 
```{r}
amoraw <- replace(amoraw,amoraw==-99.99, NA)
```

Now subset the dataset to start in 1996 (the capelin data starts in 1998, but you want some previous time period stuff)
```{r}
amoraw <- amoraw[amoraw$year >= 1996, ]
head(amoraw)
```

And just for fun, plot the AMO... follow the tutorial [here](http://www.stat.pitt.edu/stoffer/tsa4/R_toot.htm)
```{r}
amocolumn <- matrix(t(amoraw[ ,2:13]), ncol=1) #month data is in col 2 - 13
amocolumn1 <- as.vector(amocolumn)
amotimeseries <- ts(amocolumn1, frequency = 12, start = c(1996,1))
plot.ts(amotimeseries)
abline(h = 0)
dev.copy(png, "../output/env/amo.png") #this prints a png of the plot
dev.off() #this turns off the print command
```


First I will create a matrix that takes all of the raw data and then appends some extra columns - year average value, year phase (warm or cold) and then seasonal values (spring, summer, autum, winter) + seasonal phase (warm cold)

Spring:	1 March - 31 May (col 4:6) Summer: 1 June - 31 August (col 7:9) Autumn: 1 Sept - 31 Nov (col 10:12) Winter: 1 Dec - 28 Feb (col 13 from prev year, 1:2)
```{r}
amophases <- amoraw 
amophases$YearAvg <- rowMeans(amophases[2:13], na.rm = TRUE) #the month data is in col 2-13
amophases$SpringAvg <-  rowMeans(amophases[4:6], na.rm = TRUE)
amophases$SummerAvg <-  rowMeans(amophases[7:9], na.rm = TRUE)
amophases$AutumnAvg <-  rowMeans(amophases[10:12], na.rm = TRUE)
```
winter has a different format - the columns are in 1 & 2, & 13 from the previous column, which means the rowmeans function needs a bit of tweaking...


1) shift the dec column you created down by 1
```{r}
library(useful)
amophases <- shift.column(data = amophases, columns = "Dec", len = 1, up = FALSE)
amophases
write.csv(amophases, file = "../output/env/amo.csv", row.names = FALSE) #for some reason you need to write to a csv and then reload for the next step to work properly...
```

the shifted data is in Dec.Shifted...
```{r}
amophases <- read.csv("../output/env/amo.csv")
amophases$WinterAvg <- rowMeans(amophases[, c("Dec.Shifted", "Jan", "Feb")], na.rm = TRUE) 
amophases
```

Now label the phases positive, negative (or avg if any happen to be at 0)
```{r}
amophases$YearPhase[amophases$YearAvg ==0] <- "avg"
amophases$YearPhase[amophases$YearAvg >0] <- "positive"
amophases$YearPhase[amophases$YearAvg <0] <- "negative"
amophases$SpringPhase[amophases$SpringAvg ==0] <- "avg"
amophases$SpringPhase[amophases$SpringAvg >0] <- "positive"
amophases$SpringPhase[amophases$SpringAvg <0] <- "negative"
amophases$SummerPhase[amophases$SummerAvg ==0] <- "avg"
amophases$SummerPhase[amophases$SummerAvg >0] <- "positive"
amophases$SummerPhase[amophases$SummerAvg <0] <- "negative"
amophases$AutumnPhase[amophases$AutumnAvg ==0] <- "avg"
amophases$AutumnPhase[amophases$AutumnAvg >0] <- "positive"
amophases$AutumnPhase[amophases$AutumnAvg <0] <- "negative"
amophases$WinterPhase[amophases$WinterAvg ==0] <- "avg"
amophases$WinterPhase[amophases$WinterAvg >0] <- "positive"
amophases$WinterPhase[amophases$WinterAvg <0] <- "negative"
```

now save this as a new csv
```{r}
write.csv(amophases, file = "../output/env/amo.csv", row.names = FALSE)
```

# NAO

Dataset mes from [NCAR](https://climatedataguide.ucar.edu/climate-data/hurrell-north-atlantic-oscillation-nao-index-pc-based). Note I am using the monthly principal component (PC)-based indices of the North Atlantic Oscillation [(NAO)](https://climatedataguide.ucar.edu/sites/default/files/nao_pc_monthly.txt). I have already converted this file into a csv and removed unncesessary text. Note there are no headers...

```{r}
naoraw <- read.csv("../data/env/amon.us.data.csv", header = FALSE) 
head(naoraw)
```

lets give some column names. col 1  year, 2:13 are the months
```{r}
colnames(naoraw) <- c("year","1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12")
head(naoraw)
```
 
 NA values are represented by -99.99. Change these to NA
```{r}
naoraw <- replace(naoraw,naoraw==-99.99, NA)
```
 
Now subset the dataset to start in 1996 (the capelin data starts in 1998, but you want some previous time period stuff)

```{r}
nao <- naoraw[naoraw$year >= 1996, ]
head(nao) 
```

And just for fun, plot the NAO follow the tutorial here

```{r}
naocolumn <- matrix(t(amoraw[ ,2:13]), ncol=1) #month data is in col 2 - 13
naocolumn1 <- as.vector(naocolumn)
naotimeseries <- ts(naocolumn1, frequency = 12, start = c(1996,1))
plot.ts(naotimeseries)
abline(h = 0)
dev.copy(png, "../output/env/nao.png") #this prints a png of the plot
dev.off() #this turns off the print command
```

First I will create a matrix that takes all of the raw data and then appends some extra columns - year average value, year phase (warm or cold) and then seasonal values (spring, summer, autum, winter) + seasonal phase (warm cold)

Spring:	1 March - 31 May (col 4:6) Summer: 1 June - 31 August (col 7:9) Autumn: 1 Sept - 31 Nov (col 10:12) Winter: 1 Dec - 28 Feb (col 13 from prev year, 1:2)

```{r}
naophases <- nao 
naophases$YearAvg <- rowMeans(naophases[2:13], na.rm = TRUE) #the month data is in col 2-13
naophases$SpringAvg <- rowMeans(naophases[4:6], na.rm = TRUE)
naophases$SummerAvg <- rowMeans(naophases[7:9], na.rm = TRUE)
naophases$AutumnAvg <- rowMeans(naophases[10:12], na.rm = TRUE)
```

winter has a different format - the columns are in 1 & 2, & 13 from the previous column, which means the rowmeans function needs a bit of tweaking...

shift the dec column you created down by 1
```{r}
library(useful)
naophases <- shift.column(data = naophases, columns = "12", len = 1, up = FALSE)
naophases
write.csv(naophases, file = "../output/env/nao.csv", row.names = FALSE) #for some reason you need to write to a csv and then reload for the next step to work properly...

```

he shifted data is in 12.Shifted...
```{r}
naophases <- read.csv("../output/env/nao.csv")
naophases$WinterAvg <- rowMeans(naophases[ , c("X12.Shifted", "X1", "X2")], na.rm = TRUE)  #x because apparently all the col names start with x for some reason...
naophases
```

Now label the phases positive, negative (or avg if any happen to be at 0)

```{r}
naophases$YearPhase[naophases$YearAvg ==0] <- "avg"
naophases$YearPhase[naophases$YearAvg >0] <- "positive"
naophases$YearPhase[naophases$YearAvg <0] <- "negative"
naophases$SpringPhase[naophases$SpringAvg ==0] <- "avg"
naophases$SpringPhase[naophases$SpringAvg >0] <- "positive"
naophases$SpringPhase[naophases$SpringAvg <0] <- "negative"
naophases$SummerPhase[naophases$SummerAvg ==0] <- "avg"
naophases$SummerPhase[naophases$SummerAvg >0] <- "positive"
naophases$SummerPhase[naophases$SummerAvg <0] <- "negative"
naophases$AutumnPhase[naophases$AutumnAvg ==0] <- "avg"
naophases$AutumnPhase[naophases$AutumnAvg >0] <- "positive"
naophases$AutumnPhase[naophases$AutumnAvg <0] <- "negative"
naophases$WinterPhase[naophases$WinterAvg ==0] <- "avg"
naophases$WinterPhase[naophases$WinterAvg >0] <- "positive"
naophases$WinterPhase[naophases$WinterAvg <0] <- "negative"
```

now save this as a new csv

```{r}
write.csv(naophases, file = "../output/env/nao.csv", row.names = FALSE)
```

